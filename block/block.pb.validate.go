// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: block.proto

package block

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	peer "github.com/hyperledger/fabric-protos-go/peer"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = peer.TxValidationCode(0)
)

// Validate checks the field values on Block with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Block) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BlockMultiError, or nil if none found.
func (m *Block) ValidateAll() error {
	return m.validate(true)
}

func (m *Block) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockValidationError{
					field:  "Header",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockValidationError{
					field:  "Header",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockValidationError{
				field:  "Header",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BlockValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BlockValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BlockValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BlockMultiError(errors)
	}

	return nil
}

// BlockMultiError is an error wrapping multiple validation errors returned by
// Block.ValidateAll() if the designated constraints aren't met.
type BlockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockMultiError) AllErrors() []error { return m }

// BlockValidationError is the validation error returned by Block.Validate if
// the designated constraints aren't met.
type BlockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockValidationError) ErrorName() string { return "BlockValidationError" }

// Error satisfies the builtin error interface
func (e BlockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockValidationError{}

// Validate checks the field values on BlockData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BlockData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BlockDataMultiError, or nil
// if none found.
func (m *BlockData) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEnvelopes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockDataValidationError{
						field:  fmt.Sprintf("Envelopes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockDataValidationError{
						field:  fmt.Sprintf("Envelopes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockDataValidationError{
					field:  fmt.Sprintf("Envelopes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BlockDataMultiError(errors)
	}

	return nil
}

// BlockDataMultiError is an error wrapping multiple validation errors returned
// by BlockData.ValidateAll() if the designated constraints aren't met.
type BlockDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockDataMultiError) AllErrors() []error { return m }

// BlockDataValidationError is the validation error returned by
// BlockData.Validate if the designated constraints aren't met.
type BlockDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockDataValidationError) ErrorName() string { return "BlockDataValidationError" }

// Error satisfies the builtin error interface
func (e BlockDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockDataValidationError{}

// Validate checks the field values on Envelope with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Envelope) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Envelope with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnvelopeMultiError, or nil
// if none found.
func (m *Envelope) ValidateAll() error {
	return m.validate(true)
}

func (m *Envelope) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnvelopeValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnvelopeValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnvelopeValidationError{
				field:  "Payload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Signature

	// no validation rules for ValidationCode

	if len(errors) > 0 {
		return EnvelopeMultiError(errors)
	}

	return nil
}

// EnvelopeMultiError is an error wrapping multiple validation errors returned
// by Envelope.ValidateAll() if the designated constraints aren't met.
type EnvelopeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnvelopeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnvelopeMultiError) AllErrors() []error { return m }

// EnvelopeValidationError is the validation error returned by
// Envelope.Validate if the designated constraints aren't met.
type EnvelopeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnvelopeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnvelopeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnvelopeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnvelopeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnvelopeValidationError) ErrorName() string { return "EnvelopeValidationError" }

// Error satisfies the builtin error interface
func (e EnvelopeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnvelope.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnvelopeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnvelopeValidationError{}

// Validate checks the field values on Payload with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Payload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Payload with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PayloadMultiError, or nil if none found.
func (m *Payload) ValidateAll() error {
	return m.validate(true)
}

func (m *Payload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PayloadValidationError{
					field:  "Header",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PayloadValidationError{
					field:  "Header",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PayloadValidationError{
				field:  "Header",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PayloadValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PayloadValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PayloadValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RawUnparsedTransaction

	if len(errors) > 0 {
		return PayloadMultiError(errors)
	}

	return nil
}

// PayloadMultiError is an error wrapping multiple validation errors returned
// by Payload.ValidateAll() if the designated constraints aren't met.
type PayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PayloadMultiError) AllErrors() []error { return m }

// PayloadValidationError is the validation error returned by Payload.Validate
// if the designated constraints aren't met.
type PayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PayloadValidationError) ErrorName() string { return "PayloadValidationError" }

// Error satisfies the builtin error interface
func (e PayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PayloadValidationError{}

// Validate checks the field values on Header with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Header) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Header with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in HeaderMultiError, or nil if none found.
func (m *Header) ValidateAll() error {
	return m.validate(true)
}

func (m *Header) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetChannelHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HeaderValidationError{
					field:  "ChannelHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HeaderValidationError{
					field:  "ChannelHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChannelHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HeaderValidationError{
				field:  "ChannelHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSignatureHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HeaderValidationError{
					field:  "SignatureHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HeaderValidationError{
					field:  "SignatureHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignatureHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HeaderValidationError{
				field:  "SignatureHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HeaderMultiError(errors)
	}

	return nil
}

// HeaderMultiError is an error wrapping multiple validation errors returned by
// Header.ValidateAll() if the designated constraints aren't met.
type HeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HeaderMultiError) AllErrors() []error { return m }

// HeaderValidationError is the validation error returned by Header.Validate if
// the designated constraints aren't met.
type HeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HeaderValidationError) ErrorName() string { return "HeaderValidationError" }

// Error satisfies the builtin error interface
func (e HeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HeaderValidationError{}

// Validate checks the field values on SignatureHeader with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SignatureHeader) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignatureHeader with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignatureHeaderMultiError, or nil if none found.
func (m *SignatureHeader) ValidateAll() error {
	return m.validate(true)
}

func (m *SignatureHeader) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreator()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignatureHeaderValidationError{
					field:  "Creator",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignatureHeaderValidationError{
					field:  "Creator",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreator()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignatureHeaderValidationError{
				field:  "Creator",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Nonce

	if len(errors) > 0 {
		return SignatureHeaderMultiError(errors)
	}

	return nil
}

// SignatureHeaderMultiError is an error wrapping multiple validation errors
// returned by SignatureHeader.ValidateAll() if the designated constraints
// aren't met.
type SignatureHeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignatureHeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignatureHeaderMultiError) AllErrors() []error { return m }

// SignatureHeaderValidationError is the validation error returned by
// SignatureHeader.Validate if the designated constraints aren't met.
type SignatureHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignatureHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignatureHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignatureHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignatureHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignatureHeaderValidationError) ErrorName() string { return "SignatureHeaderValidationError" }

// Error satisfies the builtin error interface
func (e SignatureHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignatureHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignatureHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignatureHeaderValidationError{}

// Validate checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransactionMultiError, or
// nil if none found.
func (m *Transaction) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetChannelConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "ChannelConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "ChannelConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChannelConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "ChannelConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetActions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  fmt.Sprintf("Actions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  fmt.Sprintf("Actions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TransactionMultiError(errors)
	}

	return nil
}

// TransactionMultiError is an error wrapping multiple validation errors
// returned by Transaction.ValidateAll() if the designated constraints aren't met.
type TransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionMultiError) AllErrors() []error { return m }

// TransactionValidationError is the validation error returned by
// Transaction.Validate if the designated constraints aren't met.
type TransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionValidationError) ErrorName() string { return "TransactionValidationError" }

// Error satisfies the builtin error interface
func (e TransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionValidationError{}

// Validate checks the field values on TransactionAction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TransactionAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionAction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionActionMultiError, or nil if none found.
func (m *TransactionAction) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionActionValidationError{
					field:  "Header",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionActionValidationError{
					field:  "Header",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionActionValidationError{
				field:  "Header",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionActionValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionActionValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionActionValidationError{
				field:  "Payload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransactionActionMultiError(errors)
	}

	return nil
}

// TransactionActionMultiError is an error wrapping multiple validation errors
// returned by TransactionAction.ValidateAll() if the designated constraints
// aren't met.
type TransactionActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionActionMultiError) AllErrors() []error { return m }

// TransactionActionValidationError is the validation error returned by
// TransactionAction.Validate if the designated constraints aren't met.
type TransactionActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionActionValidationError) ErrorName() string {
	return "TransactionActionValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionActionValidationError{}

// Validate checks the field values on ChaincodeActionPayload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChaincodeActionPayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChaincodeActionPayload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChaincodeActionPayloadMultiError, or nil if none found.
func (m *ChaincodeActionPayload) ValidateAll() error {
	return m.validate(true)
}

func (m *ChaincodeActionPayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetChaincodeProposalPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChaincodeActionPayloadValidationError{
					field:  "ChaincodeProposalPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChaincodeActionPayloadValidationError{
					field:  "ChaincodeProposalPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChaincodeProposalPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChaincodeActionPayloadValidationError{
				field:  "ChaincodeProposalPayload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChaincodeActionPayloadValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChaincodeActionPayloadValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChaincodeActionPayloadValidationError{
				field:  "Action",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ChaincodeActionPayloadMultiError(errors)
	}

	return nil
}

// ChaincodeActionPayloadMultiError is an error wrapping multiple validation
// errors returned by ChaincodeActionPayload.ValidateAll() if the designated
// constraints aren't met.
type ChaincodeActionPayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChaincodeActionPayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChaincodeActionPayloadMultiError) AllErrors() []error { return m }

// ChaincodeActionPayloadValidationError is the validation error returned by
// ChaincodeActionPayload.Validate if the designated constraints aren't met.
type ChaincodeActionPayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChaincodeActionPayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChaincodeActionPayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChaincodeActionPayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChaincodeActionPayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChaincodeActionPayloadValidationError) ErrorName() string {
	return "ChaincodeActionPayloadValidationError"
}

// Error satisfies the builtin error interface
func (e ChaincodeActionPayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChaincodeActionPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChaincodeActionPayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChaincodeActionPayloadValidationError{}

// Validate checks the field values on ChaincodeProposalPayload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChaincodeProposalPayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChaincodeProposalPayload with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChaincodeProposalPayloadMultiError, or nil if none found.
func (m *ChaincodeProposalPayload) ValidateAll() error {
	return m.validate(true)
}

func (m *ChaincodeProposalPayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChaincodeProposalPayloadValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChaincodeProposalPayloadValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChaincodeProposalPayloadValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TransientMap

	if len(errors) > 0 {
		return ChaincodeProposalPayloadMultiError(errors)
	}

	return nil
}

// ChaincodeProposalPayloadMultiError is an error wrapping multiple validation
// errors returned by ChaincodeProposalPayload.ValidateAll() if the designated
// constraints aren't met.
type ChaincodeProposalPayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChaincodeProposalPayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChaincodeProposalPayloadMultiError) AllErrors() []error { return m }

// ChaincodeProposalPayloadValidationError is the validation error returned by
// ChaincodeProposalPayload.Validate if the designated constraints aren't met.
type ChaincodeProposalPayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChaincodeProposalPayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChaincodeProposalPayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChaincodeProposalPayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChaincodeProposalPayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChaincodeProposalPayloadValidationError) ErrorName() string {
	return "ChaincodeProposalPayloadValidationError"
}

// Error satisfies the builtin error interface
func (e ChaincodeProposalPayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChaincodeProposalPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChaincodeProposalPayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChaincodeProposalPayloadValidationError{}

// Validate checks the field values on ChaincodeEndorsedAction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChaincodeEndorsedAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChaincodeEndorsedAction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChaincodeEndorsedActionMultiError, or nil if none found.
func (m *ChaincodeEndorsedAction) ValidateAll() error {
	return m.validate(true)
}

func (m *ChaincodeEndorsedAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProposalResponsePayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChaincodeEndorsedActionValidationError{
					field:  "ProposalResponsePayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChaincodeEndorsedActionValidationError{
					field:  "ProposalResponsePayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProposalResponsePayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChaincodeEndorsedActionValidationError{
				field:  "ProposalResponsePayload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetEndorsement() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChaincodeEndorsedActionValidationError{
						field:  fmt.Sprintf("Endorsement[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChaincodeEndorsedActionValidationError{
						field:  fmt.Sprintf("Endorsement[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChaincodeEndorsedActionValidationError{
					field:  fmt.Sprintf("Endorsement[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ChaincodeEndorsedActionMultiError(errors)
	}

	return nil
}

// ChaincodeEndorsedActionMultiError is an error wrapping multiple validation
// errors returned by ChaincodeEndorsedAction.ValidateAll() if the designated
// constraints aren't met.
type ChaincodeEndorsedActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChaincodeEndorsedActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChaincodeEndorsedActionMultiError) AllErrors() []error { return m }

// ChaincodeEndorsedActionValidationError is the validation error returned by
// ChaincodeEndorsedAction.Validate if the designated constraints aren't met.
type ChaincodeEndorsedActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChaincodeEndorsedActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChaincodeEndorsedActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChaincodeEndorsedActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChaincodeEndorsedActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChaincodeEndorsedActionValidationError) ErrorName() string {
	return "ChaincodeEndorsedActionValidationError"
}

// Error satisfies the builtin error interface
func (e ChaincodeEndorsedActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChaincodeEndorsedAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChaincodeEndorsedActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChaincodeEndorsedActionValidationError{}

// Validate checks the field values on ProposalResponsePayload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProposalResponsePayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProposalResponsePayload with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProposalResponsePayloadMultiError, or nil if none found.
func (m *ProposalResponsePayload) ValidateAll() error {
	return m.validate(true)
}

func (m *ProposalResponsePayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProposalHash

	if all {
		switch v := interface{}(m.GetExtension()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProposalResponsePayloadValidationError{
					field:  "Extension",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProposalResponsePayloadValidationError{
					field:  "Extension",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtension()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProposalResponsePayloadValidationError{
				field:  "Extension",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProposalResponsePayloadMultiError(errors)
	}

	return nil
}

// ProposalResponsePayloadMultiError is an error wrapping multiple validation
// errors returned by ProposalResponsePayload.ValidateAll() if the designated
// constraints aren't met.
type ProposalResponsePayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProposalResponsePayloadMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProposalResponsePayloadMultiError) AllErrors() []error { return m }

// ProposalResponsePayloadValidationError is the validation error returned by
// ProposalResponsePayload.Validate if the designated constraints aren't met.
type ProposalResponsePayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProposalResponsePayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProposalResponsePayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProposalResponsePayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProposalResponsePayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProposalResponsePayloadValidationError) ErrorName() string {
	return "ProposalResponsePayloadValidationError"
}

// Error satisfies the builtin error interface
func (e ProposalResponsePayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProposalResponsePayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProposalResponsePayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProposalResponsePayloadValidationError{}

// Validate checks the field values on ChaincodeAction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ChaincodeAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChaincodeAction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChaincodeActionMultiError, or nil if none found.
func (m *ChaincodeAction) ValidateAll() error {
	return m.validate(true)
}

func (m *ChaincodeAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetResults()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChaincodeActionValidationError{
					field:  "Results",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChaincodeActionValidationError{
					field:  "Results",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResults()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChaincodeActionValidationError{
				field:  "Results",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEvents()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChaincodeActionValidationError{
					field:  "Events",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChaincodeActionValidationError{
					field:  "Events",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEvents()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChaincodeActionValidationError{
				field:  "Events",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChaincodeActionValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChaincodeActionValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChaincodeActionValidationError{
				field:  "Response",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetChaincodeId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChaincodeActionValidationError{
					field:  "ChaincodeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChaincodeActionValidationError{
					field:  "ChaincodeId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetChaincodeId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChaincodeActionValidationError{
				field:  "ChaincodeId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ChaincodeActionMultiError(errors)
	}

	return nil
}

// ChaincodeActionMultiError is an error wrapping multiple validation errors
// returned by ChaincodeAction.ValidateAll() if the designated constraints
// aren't met.
type ChaincodeActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChaincodeActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChaincodeActionMultiError) AllErrors() []error { return m }

// ChaincodeActionValidationError is the validation error returned by
// ChaincodeAction.Validate if the designated constraints aren't met.
type ChaincodeActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChaincodeActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChaincodeActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChaincodeActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChaincodeActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChaincodeActionValidationError) ErrorName() string { return "ChaincodeActionValidationError" }

// Error satisfies the builtin error interface
func (e ChaincodeActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChaincodeAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChaincodeActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChaincodeActionValidationError{}

// Validate checks the field values on TxReadWriteSet with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TxReadWriteSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TxReadWriteSet with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TxReadWriteSetMultiError,
// or nil if none found.
func (m *TxReadWriteSet) ValidateAll() error {
	return m.validate(true)
}

func (m *TxReadWriteSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DataModel

	for idx, item := range m.GetNsRwset() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TxReadWriteSetValidationError{
						field:  fmt.Sprintf("NsRwset[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TxReadWriteSetValidationError{
						field:  fmt.Sprintf("NsRwset[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TxReadWriteSetValidationError{
					field:  fmt.Sprintf("NsRwset[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TxReadWriteSetMultiError(errors)
	}

	return nil
}

// TxReadWriteSetMultiError is an error wrapping multiple validation errors
// returned by TxReadWriteSet.ValidateAll() if the designated constraints
// aren't met.
type TxReadWriteSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TxReadWriteSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TxReadWriteSetMultiError) AllErrors() []error { return m }

// TxReadWriteSetValidationError is the validation error returned by
// TxReadWriteSet.Validate if the designated constraints aren't met.
type TxReadWriteSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TxReadWriteSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TxReadWriteSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TxReadWriteSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TxReadWriteSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TxReadWriteSetValidationError) ErrorName() string { return "TxReadWriteSetValidationError" }

// Error satisfies the builtin error interface
func (e TxReadWriteSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTxReadWriteSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TxReadWriteSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TxReadWriteSetValidationError{}

// Validate checks the field values on NsReadWriteSet with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NsReadWriteSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NsReadWriteSet with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NsReadWriteSetMultiError,
// or nil if none found.
func (m *NsReadWriteSet) ValidateAll() error {
	return m.validate(true)
}

func (m *NsReadWriteSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Namespace

	if all {
		switch v := interface{}(m.GetRwset()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NsReadWriteSetValidationError{
					field:  "Rwset",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NsReadWriteSetValidationError{
					field:  "Rwset",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRwset()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NsReadWriteSetValidationError{
				field:  "Rwset",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCollectionHashedRwset() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NsReadWriteSetValidationError{
						field:  fmt.Sprintf("CollectionHashedRwset[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NsReadWriteSetValidationError{
						field:  fmt.Sprintf("CollectionHashedRwset[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NsReadWriteSetValidationError{
					field:  fmt.Sprintf("CollectionHashedRwset[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NsReadWriteSetMultiError(errors)
	}

	return nil
}

// NsReadWriteSetMultiError is an error wrapping multiple validation errors
// returned by NsReadWriteSet.ValidateAll() if the designated constraints
// aren't met.
type NsReadWriteSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NsReadWriteSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NsReadWriteSetMultiError) AllErrors() []error { return m }

// NsReadWriteSetValidationError is the validation error returned by
// NsReadWriteSet.Validate if the designated constraints aren't met.
type NsReadWriteSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NsReadWriteSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NsReadWriteSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NsReadWriteSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NsReadWriteSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NsReadWriteSetValidationError) ErrorName() string { return "NsReadWriteSetValidationError" }

// Error satisfies the builtin error interface
func (e NsReadWriteSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNsReadWriteSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NsReadWriteSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NsReadWriteSetValidationError{}

// Validate checks the field values on CollectionHashedReadWriteSet with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionHashedReadWriteSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionHashedReadWriteSet with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionHashedReadWriteSetMultiError, or nil if none found.
func (m *CollectionHashedReadWriteSet) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionHashedReadWriteSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CollectionName

	if all {
		switch v := interface{}(m.GetHashedRwset()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CollectionHashedReadWriteSetValidationError{
					field:  "HashedRwset",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CollectionHashedReadWriteSetValidationError{
					field:  "HashedRwset",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHashedRwset()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CollectionHashedReadWriteSetValidationError{
				field:  "HashedRwset",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PvtRwsetHash

	if len(errors) > 0 {
		return CollectionHashedReadWriteSetMultiError(errors)
	}

	return nil
}

// CollectionHashedReadWriteSetMultiError is an error wrapping multiple
// validation errors returned by CollectionHashedReadWriteSet.ValidateAll() if
// the designated constraints aren't met.
type CollectionHashedReadWriteSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionHashedReadWriteSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionHashedReadWriteSetMultiError) AllErrors() []error { return m }

// CollectionHashedReadWriteSetValidationError is the validation error returned
// by CollectionHashedReadWriteSet.Validate if the designated constraints
// aren't met.
type CollectionHashedReadWriteSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionHashedReadWriteSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionHashedReadWriteSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionHashedReadWriteSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionHashedReadWriteSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionHashedReadWriteSetValidationError) ErrorName() string {
	return "CollectionHashedReadWriteSetValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionHashedReadWriteSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionHashedReadWriteSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionHashedReadWriteSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionHashedReadWriteSetValidationError{}

// Validate checks the field values on Endorsement with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Endorsement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Endorsement with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EndorsementMultiError, or
// nil if none found.
func (m *Endorsement) ValidateAll() error {
	return m.validate(true)
}

func (m *Endorsement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEndorser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EndorsementValidationError{
					field:  "Endorser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EndorsementValidationError{
					field:  "Endorser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndorser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EndorsementValidationError{
				field:  "Endorser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Signature

	if len(errors) > 0 {
		return EndorsementMultiError(errors)
	}

	return nil
}

// EndorsementMultiError is an error wrapping multiple validation errors
// returned by Endorsement.ValidateAll() if the designated constraints aren't met.
type EndorsementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EndorsementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EndorsementMultiError) AllErrors() []error { return m }

// EndorsementValidationError is the validation error returned by
// Endorsement.Validate if the designated constraints aren't met.
type EndorsementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EndorsementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EndorsementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EndorsementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EndorsementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EndorsementValidationError) ErrorName() string { return "EndorsementValidationError" }

// Error satisfies the builtin error interface
func (e EndorsementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEndorsement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EndorsementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EndorsementValidationError{}

// Validate checks the field values on BlockMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BlockMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BlockMetadataMultiError, or
// nil if none found.
func (m *BlockMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOrdererSignatures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockMetadataValidationError{
						field:  fmt.Sprintf("OrdererSignatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockMetadataValidationError{
						field:  fmt.Sprintf("OrdererSignatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockMetadataValidationError{
					field:  fmt.Sprintf("OrdererSignatures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RawUnparsedMetadataSignatures

	if len(errors) > 0 {
		return BlockMetadataMultiError(errors)
	}

	return nil
}

// BlockMetadataMultiError is an error wrapping multiple validation errors
// returned by BlockMetadata.ValidateAll() if the designated constraints
// aren't met.
type BlockMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockMetadataMultiError) AllErrors() []error { return m }

// BlockMetadataValidationError is the validation error returned by
// BlockMetadata.Validate if the designated constraints aren't met.
type BlockMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockMetadataValidationError) ErrorName() string { return "BlockMetadataValidationError" }

// Error satisfies the builtin error interface
func (e BlockMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockMetadataValidationError{}

// Validate checks the field values on OrdererSignature with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OrdererSignature) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrdererSignature with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrdererSignatureMultiError, or nil if none found.
func (m *OrdererSignature) ValidateAll() error {
	return m.validate(true)
}

func (m *OrdererSignature) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIdentity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrdererSignatureValidationError{
					field:  "Identity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrdererSignatureValidationError{
					field:  "Identity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrdererSignatureValidationError{
				field:  "Identity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Signature

	if len(errors) > 0 {
		return OrdererSignatureMultiError(errors)
	}

	return nil
}

// OrdererSignatureMultiError is an error wrapping multiple validation errors
// returned by OrdererSignature.ValidateAll() if the designated constraints
// aren't met.
type OrdererSignatureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrdererSignatureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrdererSignatureMultiError) AllErrors() []error { return m }

// OrdererSignatureValidationError is the validation error returned by
// OrdererSignature.Validate if the designated constraints aren't met.
type OrdererSignatureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrdererSignatureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrdererSignatureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrdererSignatureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrdererSignatureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrdererSignatureValidationError) ErrorName() string { return "OrdererSignatureValidationError" }

// Error satisfies the builtin error interface
func (e OrdererSignatureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrdererSignature.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrdererSignatureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrdererSignatureValidationError{}
